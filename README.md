## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2401`

#### Выполнил: `Лашкова Екатерина Александровна`

#### Вариант: `16`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

>  Напишите программу на Java, которая выполняет следующие действия с
двумерным массивом вещественных чисел (каждая строка может иметь
разную длину):
>1. Считывает с консоли число строк N. Затем для каждой строки вво
   дит количество элементов Mi, после чего вводит элементы строки,
   формируя массив размером N строк разной длины.
>2. Сортирует строки массива по возрастанию количества отрицатель
   ных чисел в строке. Если количества равны, сортирует строки по
   возрастанию суммы положительных чисел.
>3. Находит и выводит максимальное число в массиве и его индексы
   (номер строки и позиция в строке).
>4. Выводит элементы массива в виде матрицы, заполняя недостающие
   элементы в строках символом ‘*’.
>5. Заменяет все числа в массиве на их обратные значения (1/число)
   и выводит полученный массив.

Для решения данной задачи нужно сначала создать и заполнить массив, за тем посчитать количество чисел меньше нуля 
в каждой строчке и запомнить эти данные, а так же посчитать сумму оставшихся чисел и тоже запомнить. После этого
отсортировать строки по количеству отрицательных чисел, если количество одиннаковое, то по сумме положительных чисел.
После нужно найти максимальное число в массиве и запомнить его индексы. Вывести отсортированный массив в виде матрицы, заполняя недостающие элементы "*".
Затем повтороно вывести этот массив , но заменяя все числа на обратные.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать вещественные числа. Так как ограничесние не заданы, то будем считать что числа по модулю не будут выходить за десять в девятой степени, так как числа больше не понадобятся в данном случае.
|                     | Тип                | min значение    | max значение   |
|---------------------|--------------------|-----------------|----------------|
| X (Числа в массиве) | Вещественное число | -10<sup>9</sup> | 10<sup>9</sup> |

#### Данные на выход

Т.к. программа должна вывести двумерный массив вещественных чисел, а также максимальное число и его индексы,
то на выход мы получаем вещественые числа не превыщающие по модулю десять в девятой.

|        | Тип                                | min значение    | max значение   |
|--------|------------------------------------|-----------------|----------------|
| Числа  | Вещественные неотрицательное число | -10<sup>9</sup> | 10<sup>9</sup> |

### 3. Выбор структуры данных

Программа получает какое-то количество вещественных чисел. Для их хранения создадим двумерный массив.

|                      | название массива | Тип (в Java) | 
|----------------------|------------------|--------------|
| а (Двумерный массив) | `а`              | `double`     |

Для вывода результата не надо сохранять массив в отдельной переменной.

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает двумерный массив вещественных чисел.

2. **Сравнение чисел:**  
   Программа сравнивает количество отрицательных чисел в строках массива и распологает по возрастанию, если же количество одинаковое,
   то по возрастанию суммы положительных чисел.

3. **Нахождение максимального числа и запоминание его индексов:**
   Проверяем все числа, если число больше максимального, то запомираем его значение в переменную максимального и его индексы.

4. **Заполняем не достающие элементы в строках "*":**  
   Находим самую длинную строку в массиве и запоминаем ее длину. Сравниваем все строки с самой длинной, и заполняем "*" недостающие элементы.
5. **Выводим на экран массив с обычными элементами и обратными:**
   Выводим на экран массив. А за тем повторно выводим но уже заменяя элементы на обратные.

### 5. Программа

```java
import java.io.PrintStream;
import java.util.Scanner;
public class Main {
   public static Scanner in = new Scanner(System.in);
   public static PrintStream out = System.out;
   public static void main(String[] args) {
      int N = in.nextInt();
      double [][] a = new double[N][];
      //Заполняем двумерный массив
      for (int i = 0; i < a.length; i++) {
         int Mi = in.nextInt();
         a [i] = new double[Mi];
         for(int j = 0 ; j < a[i].length ; j++) {
            a[i][j] = in.nextDouble();
         }
      }
      int [] mine = new int[N];
      double [] symm = new double[N];
      double symmpol = 0;
      int kolot = 0;
      //Создаем два дополнительных массива, один из них заполняем количеством отрицательных чисел в строке, а второй суммой положительных чисел в этой же строке
      for (int i = 0 ; i < a.length ; i++) {
         for (int j = 0 ; j < a[i].length ; j++) {
            if (a[i][j] < 0)
               kolot++;
            else
               symmpol += a[i][j];
         }
         mine [i] = kolot;
         symm [i] = symmpol;
         symmpol = 0;
         kolot = 0;
      }
      int dlinst = 0;
      int kolch = 0;
      //Находим самую длинную сторку и считаем количество чисел в ней
      for (int i = 0 ; i < a.length ; i++) {
         for (int j = 0 ; j < a[i].length ; j++)
            kolch++;
         if(dlinst<kolch)
            dlinst = kolch;
         kolch = 0;
      }
      double [] perestonovka;
      //проверяем массив с количеством отрицательных чисел, если они расположены не по возрастанию, то меняем местами цифры, строки в двумерном массиве и массив с суммой положительных цифр тоже,
      // если же количество отрицательных чисел одинаковое, то проверяем массив с суммой положительных чисел и меняем местами значения, если первое значение больше второго
      for (int j = 0; j < a.length; j++) {
         for (int i = 0; i < a.length; i++) {
            if(i>0) {
               if (mine[i - 1] > mine[i]){
                  kolot = mine[i - 1];
                  mine[i - 1] = mine[i];
                  mine[i] = kolot;
                  perestonovka = a[i - 1];
                  a[i-1] = a[i];
                  a[i] = perestonovka;
                  symmpol = symm[i-1];
                  symm[i-1] = symm[i];
                  symm[i] = symmpol;
               }
               else if(mine[i-1] == mine[i]){
                  if(symm[i-1] > symm[i]){
                     perestonovka = a[i - 1];
                     a[i-1] = a[i];
                     a[i] = perestonovka;
                     symmpol = symm[i-1];
                     symm[i-1] = symm[i];
                     symm[i] = symmpol;
                  }
               }

            }
         }
      }
      double maxchisl = 0;
      int maxi = 0;
      int maxj = 0;
      //Находим максимальное число и запоминаем его индексы
      for (int i = 0 ; i < a.length ; i++) {
         for (int j = 0 ; j < a[i].length ; j++){
            if(maxchisl < a[i][j]){
               maxchisl = a[i][j];
               maxi = i;
               maxj = j;
            }
         }
      }
      //Выводим эти значения на экран
      out.println("Максимальное число: " + maxchisl);
      out.println("Номер строки и позиция в строке: " + maxi + " " + maxj);
      //Делаем так, чтобы длиннна строк была везде одинаковая, заполняя пробелы звездочками и выводим двумерный массив на экран
      for (int i = 0 ; i < a.length ; i++) {
         for (int j = 0 ; j < a[i].length ; j++) {
            out.print((a[i][j]) + " ");
            kolch++;
         }
         while (kolch != dlinst){
            out.print("* ");
            kolch++;
         }
         kolch = 0;
         out.println();
      }
      out.println();
      // Заменяет все числа в массиве на их обратные значения и выводит полученный массив
      for (int i = 0 ; i < a.length ; i++) {
         for (int j = 0; j < a[i].length; j++) {
            double gul = 1/(a[i][j]);
            out.printf("%.3f", gul);
            out.print(" ");
         }
         out.println();
      }
   }
}
```

### 6. Анализ правильности решения

Программа работает корректно.

1. Тест строки расположены по убыванию количества отрицательных чисел:

    - **Input**:
        ```
        4
        4
      -1 -2 -3 -4
        3
      -1 -2 -3
        3
      -1 -2 3
        3
      -1 -3 4

        ```

    - **Output**:
        ```
        Максимальное число: 4.0
      Номер строки и позиция в строке: 1 2
      -1.0 -2.0 3.0 *
      -1.0 -3.0 4.0 *
      -1.0 -2.0 -3.0 *
      -1.0 -2.0 -3.0 -4.0

      -1,000 -0,500 0,333
      -1,000 -0,333 0,250
      -1,000 -0,500 -0,333
      -1,000 -0,500 -0,333 -0,250
        ```

2. Тест на часть строк расположено не по порядку и есть где количсетво отрицательных чисел одинаковое:

     - **Input**:
     ```
             4
        4
        -1 2 3 4
        4
        -4 2 4 0
        3
        -1 -2 4
        3
        -1 -3 3

     ```

     - **Output**:
     ```
         Максимальное число: 4.0
         Номер строки и позиция в строке: 0 2
         -4.0 2.0 4.0 0.0
         -1.0 2.0 3.0 4.0
         -1.0 -3.0 3.0 *
         -1.0 -2.0 4.0 *

         -0,250 0,500 0,250 Infinity
         -1,000 0,500 0,333 0,250
         -1,000 -0,333 0,333
         -1,000 -0,500 0,250
     ```

3. Все строки расположены по порядку:

    - **Input**:
        ```
        4
        4
      1 2 3 4
        3
      -1 2 3
        3
      -1 -2 3
        4
      -1 -2 -3 4
        ```

    - **Output**:
        ```
        Максимальное число: 4.0
        Номер строки и позиция в строке: 0 3
        1.0 2.0 3.0 4.0
        -1.0 2.0 3.0 *
        -1.0 -2.0 3.0 *
        -1.0 -2.0 -3.0 4.0
   
        1,000 0,500 0,333 0,250
        -1,000 0,500 0,333
        -1,000 -0,500 0,333
        -1,000 -0,500 -0,333 0,250
       ```

